{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>The framework for everything roblox Made with  by @ratplier</p> <p>framework inspired by flamework and prvdmwrong</p>"},{"location":"#boilerplate","title":"Boilerplate","text":"<p>The bare minimal example of a provider , which can listen to any lifecycle event</p> <pre><code>local artwork = require(\"@packages/artwork\")\n\nlocal provider = {}\nartwork.register(provider)\n</code></pre>"},{"location":"#full-example","title":"Full Example","text":"<p>A more in-depth example of a framework usage</p> <pre><code>-- DataProvider.luau\nlocal artwork = require(\"@packages/artwork\")\n\nlocal DataProvider = {\n    registeredPlayers = {},\n    data = {},\n}\n\nfunction DataProvider.registerPlayer(player: Player)\n    if DataProvider.registeredPlayers[player.UserId] then return end\n\n    DataProvider.data[player.UserId] = {}\n    DataProvider.registeredPlayers[player.UserId] = true\nend\n\nfunction DataProvider.setData(player: Player, key: string, value: any)\n    DataProvider.registerPlayer(player)\n\n    local playerData = DataProvider.data[player.UserId]\n    playerData[key] = value\nend\n\nreturn artwork.register(DataProvider)\n</code></pre> <pre><code>-- CoinsProvider.luau\nlocal artwork = require(\"@packages/artwork\")\n\nlocal CoinsProvider = {\n    dataProvider = require(\"DataProvider\")\n}\n\nfunction CoinsProvider.setCoins(player: Player, amount: number)\n    CoinsProvider.dataProvider.setData(player, \"Coins\", amount)\nend\n\nreturn artwork.register(CoinsProvider)\n</code></pre> <pre><code>-- main.server.luau\nlocal artwork = require(\"@packages/artwork\")\n\nartwork.loadDescendants(\"@providers\")\nlocal shutdown = artwork.ignite()\n\ngame:BindToClose(shutdown)\n</code></pre>"},{"location":"refrence/core/","title":"Core","text":""},{"location":"refrence/core/#types","title":"Types","text":""},{"location":"refrence/core/#object","title":"object","text":"<p>The <code>object</code> type represents a generic object in the framework. It is used as a base type for structures. <pre><code>type object = { [any]: any }\n</code></pre></p>"},{"location":"refrence/core/#predicate","title":"predicate","text":"<p>The <code>predicate</code> type represents a function that takes a value of type <code>T</code> and returns a boolean. <pre><code>type predicate&lt;T&gt; = (T) -&gt; boolean\n</code></pre></p>"},{"location":"refrence/core/#methods","title":"Methods","text":""},{"location":"refrence/core/#loaddescendants","title":"loadDescendants","text":"<p>The <code>artwork.loadDescendants</code> method is used to load all modules within the descendants of a given parent instance. This method accepts a parent of type <code>Instance</code> and an optional <code>predicate</code> function, which can be used to filter the descendants that should be loaded. If a <code>predicate</code> is provided, only the descendants for which the predicate returns <code>true</code> will be loaded.</p> <p>Information</p> <p>This is a generic module loader, there are no extra features included in the source method.</p> <pre><code>function artwork.loadDescendants(parent: Instance, predicate: predicate&lt;Instance&gt;?): void\n</code></pre>"},{"location":"refrence/core/#loadchildren","title":"loadChildren","text":"<p>The <code>artwork.loadChildren</code> method is used to load all modules within the children of a given parent instance. This method accepts a parent of type <code>Instance</code> and an optional <code>predicate</code> function, which can be used to filter the children that should be loaded. If a <code>predicate</code> is provided, only the children for which the predicate returns <code>true</code> will be loaded.</p> <p>Information</p> <p>This is a generic module loader, there are no extra features included in the source method.</p> <pre><code>function artwork.loadChildren(parent: Instance, predicate: predicate&lt;Instance&gt;?): void\n</code></pre>"},{"location":"refrence/core/#register","title":"register","text":"<p>The <code>artwork.register</code> function registers a object for listening to lifecycles. The priority determines the order in which objects are registered when the framework is ignited. If no priority is specified, the default priority of <code>1</code> is used. The function returns the same table of members that was passed to it.</p> <p>Watch out</p> <p>The higher the priority, the earlier the provider is registered on ignition. The default priority is <code>1</code> and providers with lower priority are registered after providers with a higher priority.</p> <pre><code>function artwork.register(members: object&lt;T&gt;, priority: number?): T\n</code></pre>"},{"location":"refrence/core/#listen","title":"listen","text":"<p>The <code>artwork.listen</code> method is used to listen to a specific lifecycle event. It returns a cleanup function to disconnect the listener. <pre><code>function artwork.listen(name: string, listener: (...any) -&gt; ()): () -&gt; ()\n</code></pre></p>"},{"location":"refrence/core/#ignited","title":"ignited","text":"<p>The <code>artwork.ignited</code> method is used to check if the framework is currently ignited. <pre><code>function artwork.ignited(): boolean\n</code></pre></p>"},{"location":"refrence/core/#shutdown","title":"shutdown","text":"<p>The <code>artwork.shutdown</code> method is used to check if the framework is currently shutdown. <pre><code>function artwork.shutdown(): boolean\n</code></pre></p>"},{"location":"refrence/core/#ignite","title":"ignite","text":"<p>The <code>artwork.ignite</code> method is used to start the framework by initializing all registered providers and setting up the necessary event listeners. It processes providers based on their priority and also returns a function to shutdown the framework.</p> <pre><code>function artwork.ignite(): void\n</code></pre>"},{"location":"refrence/core/#extend","title":"extend","text":"<p>The <code>artwork.extend</code> method is used to extend a table with other tables. It merges all the tables with the highest priority being the last given argument. It is also fully strictly typed and is very useful in creating [extensions] for the library. <pre><code>function artwork.extend(...: object&lt;any&gt;): object&lt;any&gt;\n</code></pre></p>"},{"location":"refrence/core/#properties","title":"Properties","text":""},{"location":"refrence/core/#version","title":"version","text":"<p>The <code>artwork.version</code> method is used to get the current version of the framework. It returns a string in the format of <code>major.minor</code>. <pre><code>string artwork.version\n</code></pre></p>"},{"location":"refrence/modding/","title":"Modding","text":""},{"location":"refrence/modding/#methods","title":"Methods","text":""},{"location":"refrence/modding/#addlistener","title":"addListener","text":"<p>Registers an object as a listener. The API scans the object for string keys with function values and subscribes them to the corresponding lifecycle events.</p> <pre><code>function Modding.addListener(object: object, ignoreList: { string }?)\n</code></pre> <p>Parameters</p> <ul> <li><code>object</code> (<code>table</code>): The listener object to register.</li> <li><code>ignoreList</code> (<code>{string}?</code>): An optional array of string keys to ignore. Callbacks with these names will not be registered.</li> </ul> <pre><code>local MyListener = {\n    onStart = function()\n        print(\"MyListener has started!\")\n    end,\n\n    onStop = function()\n        print(\"MyListener is shutting down.\")\n    end\n}\n\n-- Register the entire object as a listener\nModding.addListener(MyListener)\n</code></pre>"},{"location":"refrence/modding/#removelistener","title":"removeListener","text":"<p>Removes and cleans up all event subscriptions for a given listener object. This is crucial for preventing memory leaks when a listener is disabled or unloaded.</p> <pre><code>function Modding.removeListener(object: object)\n</code></pre> <p>Parameters</p> <ul> <li><code>object</code> (<code>table</code>): The listener object to unregister.</li> </ul> <pre><code>-- Assuming MyListener was added previously\nModding.removeListener(MyListener)\n</code></pre>"},{"location":"refrence/modding/#addlifecyclelistener","title":"addLifecycleListener","text":"<p>A convenience function for adding a single event listener without creating a full object. It returns a <code>cleanup</code> function that can be called to remove the listener.</p> <pre><code>function Modding.addLifecycleListener(name: string, callback: (...any) -&gt; ()) -&gt; (() -&gt; ())\n</code></pre> <p>Parameters</p> <ul> <li><code>name</code> (<code>string</code>): The ID of the event to listen for.</li> <li><code>callback</code> (<code>function</code>): The function to execute when the event fires.</li> </ul> <p>Returns</p> <ul> <li>(<code>function</code>): A function that, when called, will remove the listener.</li> </ul> <pre><code>local function onPlayerChat(player, message)\n    print(player.Name .. \": \" .. message)\nend\n\n-- Add the listener and store the disconnect function\nlocal disconnectChatListener = Modding.addLifecycleListener(\"onPlayerChat\", onPlayerChat)\n\n-- Sometime later, to stop listening...\ndisconnectChatListener()\n</code></pre>"},{"location":"refrence/modding/#getlisteners","title":"getListeners","text":"<p>Gets all the listeners under a specific id. The resulting array is not ordered.</p> <pre><code>function Modding.getListeners(id: string) -&gt; { object }\n</code></pre> <p>Parameters</p> <ul> <li><code>id</code> (<code>string</code>): The specific event ID to watch for.</li> </ul> <p>Returns</p> <ul> <li>(<code>{ object }</code>): An array of listener objects that implement the given event ID.</li> </ul> <pre><code>local listeners = Modding.getListeners(\"onPlayerChat\")\n</code></pre>"},{"location":"refrence/modding/#onlisteneradded","title":"onListenerAdded","text":"<p>Connects a callback that fires whenever a listener is added via <code>Modding.addListener</code>.</p> <p>The function can operate in two modes: 1. Global: If <code>id</code> is <code>nil</code>, the callback fires for any listener added. 2. Specific: If an <code>id</code> is provided, the callback fires only when a listener subscribing to that specific event ID is added.</p> <p>In both modes, the callback will be immediately fired for all already existing listeners that match the criteria.</p> <pre><code>function Modding.onListenerAdded(callback: (object: object) -&gt; (), id: string?) -&gt; RBXScriptConnection\n</code></pre> <p>Parameters</p> <ul> <li><code>callback</code> (<code>function</code>): A function that receives the listener object that was added.</li> <li><code>id</code> (<code>string?</code>): Optional. The specific event ID to watch for.</li> </ul> <p>Returns</p> <ul> <li>(<code>RBXScriptConnection</code>): A connection object that can be disconnected to stop listening.</li> </ul> <pre><code>-- Listen for any listener that implements \"OnUpdate\"\nlocal connection = Modding.onListenerAdded(function(listenerObject)\n    print(\"A new listener for OnUpdate was just added!\")\n    -- Maybe do something with listenerObject here\nend, \"OnUpdate\")\n\n-- Listen for any new listener, regardless of its events\nModding.onListenerAdded(function(listenerObject)\n    print(\"A new listener was added to the system.\")\nend)\n\n-- Stop listening after a while...\nconnection:Disconnect()\n</code></pre>"},{"location":"refrence/modding/#onlistenerremoved","title":"onListenerRemoved","text":"<p>Connects a callback that fires whenever a listener is removed via <code>Modding.removeListener</code>.</p> <pre><code>function Modding.onListenerRemoved(callback: (object: object) -&gt; (), id: string?) -&gt; RBXScriptConnection\n</code></pre> <p>Parameters</p> <ul> <li><code>callback</code> (<code>function</code>): A function that receives the listener object that was added.</li> <li><code>id</code> (<code>string?</code>): Optional. The specific event ID to watch for.</li> </ul> <p>Returns</p> <ul> <li>(<code>RBXScriptConnection</code>): A connection object that can be disconnected to stop listening.</li> </ul> <pre><code>-- Listen for when any listener with an \"OnUpdate\" event is removed\nlocal connection = Modding.onListenerRemoved(function(listenerObject)\n    print(\"A listener for OnUpdate was removed.\")\nend, \"OnUpdate\")\n\n-- Stop listening after a while...\nconnection:Disconnect()\n</code></pre>"},{"location":"refrence/reflect/","title":"Reflect","text":""},{"location":"refrence/reflect/#methods","title":"Methods","text":""},{"location":"refrence/reflect/#definemetadata","title":"defineMetadata","text":"<p>Defines or updates a piece of metadata for an object. This is the primary function for writing metadata. If the object has not been seen by the API before, it will be registered automatically.</p> <pre><code>function Reflect.defineMetadata(object: object, key: string, value: unknown)\n</code></pre> <p>Parameters</p> <ul> <li><code>object</code> (<code>table</code>): The target object to associate metadata with.</li> <li><code>key</code> (<code>string</code>): The key for the piece of metadata.</li> <li><code>value</code> (<code>any</code>): The value of the metadata to store.</li> </ul> <pre><code>local player = { name = \"Alice\", health = 100 }\n\n-- Associate some metadata with the 'player' object\nReflect.defineMetadata(player, \"LastLogin\", os.time())\nReflect.defineMetadata(player, \"IsAdmin\", false)\n\n-- Note: The 'player' table itself remains unchanged.\n-- player.IsAdmin is still nil\n</code></pre>"},{"location":"refrence/reflect/#readmetadata","title":"readMetadata","text":"<p>Reads a piece of metadata from an object for a given key.</p> <pre><code>function Reflect.readMetadata(object: object, key: string): unknown\n</code></pre> <p>Parameters</p> <ul> <li><code>object</code> (<code>table</code>): The target object.</li> <li><code>key</code> (<code>string</code>): The key of the metadata to retrieve.</li> </ul> <p>Returns</p> <ul> <li>(<code>any</code>): The value of the metadata, or <code>nil</code> if the key or object does not have metadata defined.</li> </ul> <pre><code>local isAdmin = Reflect.readMetadata(player, \"IsAdmin\")\nprint(\"Is Admin:\", isAdmin)\n-- &gt; Is Admin: false\n</code></pre>"},{"location":"refrence/reflect/#getmetadata","title":"getMetadata","text":"<p>Retrieves the entire metadata table for a given object. This is useful if you need to read multiple metadata keys at once. If the object has no metadata, it will be registered automatically.</p> <pre><code>function Reflect.getMetadata(object: object): metadata\n</code></pre> <p>Parameters</p> <ul> <li><code>object</code> (<code>table</code>): The target object.</li> </ul> <p>Returns</p> <ul> <li>(<code>table</code>): The complete metadata table for the object. Changes to this table will be persisted.</li> </ul> <pre><code>-- Get the whole metadata container\nlocal allMeta = Reflect.getMetadata(player)\n\n-- You can read from it...\nprint(\"Is Admin:\", allMeta.IsAdmin) -- &gt; false\n\n-- ...or write to it directly\nallMeta.NewValue = \"hello\"\nprint(Reflect.readMetadata(player, \"NewValue\")) -- &gt; hello\n</code></pre>"},{"location":"refrence/reflect/#register","title":"register","text":"<p>Explicitly registers an object with the Reflect API, preparing it for metadata storage.</p> <p>Note</p> <p>In normal usage, you do not need to call this function. <code>defineMetadata</code> and <code>getMetadata</code> will call it automatically. It's provided for edge cases where you might want to pre-register a batch of objects.</p> <pre><code>function Reflect.register(object: object)\n</code></pre> <p>Parameters</p> <ul> <li><code>object</code> (<code>table</code>): The object to register.</li> </ul> <pre><code>local someObject = {}\nReflect.register(someObject)\n-- someObject is now known to the Reflect API\n</code></pre>"},{"location":"refrence/reflect/#getid","title":"getId","text":"<p>Gets the unique internal ID string generated for an object. This is mainly useful for debugging.</p> <pre><code>function Reflect.getId(object: object): string\n</code></pre> <p>Parameters</p> <ul> <li><code>object</code> (<code>table</code>): The target object.</li> </ul> <p>Returns</p> <ul> <li>(<code>string</code>): The unique ID used by the API to track the object (e.g., <code>reflect:12345678</code>).</li> </ul> <pre><code>local myObject = {}\nlocal id = Reflect.getId(myObject)\nprint(id) -- e.g., \"reflect:59103819\"\n</code></pre>"},{"location":"tutorials/installation/","title":"Installation","text":"<p>artwork is available to download as packages for your game. you can use <code>pesde</code> or <code>wally</code> to install the framework. you can also download a binary from the github releases or build it yourself.</p>"},{"location":"tutorials/installation/#from-pesde-recommended","title":"From pesde (recommended)","text":"<ol> <li>Make sure you have pesde installed.</li> <li>Add the package     <pre><code>pesde add ratplier/artwork\n</code></pre></li> <li>Import the package     <pre><code>local art = require(ReplicatedStorage.roblox_packages.artwork)\n</code></pre></li> </ol>"},{"location":"tutorials/installation/#from-wally","title":"From wally","text":"<ol> <li>Make sure you have wally installed.</li> <li>Add the package     <pre><code>artwork = \"ratplier/artwork@1.0.0\"\n</code></pre></li> <li>Import the package     <pre><code>local art = require(ReplicatedStorage.Packages.artwork)\n</code></pre></li> </ol>"},{"location":"tutorials/installation/#from-source","title":"From source","text":"<ol> <li>Clone the artwork repository     <pre><code>git clone https://github.com/ratplier/artwork.git\ncd artwork\n</code></pre></li> <li>Install all tools     <pre><code>rokit install\n</code></pre></li> <li>Build with rojo     <pre><code>rojo build -o out/artwork.rbxm\n</code></pre></li> </ol>"},{"location":"tutorials/fundamentals/dependencies/","title":"Dependencies","text":"<p>To add dependencies to a provider, you can assign other registered providers to specific keys within your provider table. The key names are arbitrary, but using descriptive names is recommended.</p> <p>To set up a dependency, first require the module where the dependency is defined, and then assign it to a key in your provider table. Ensure the dependency is registered before registering your provider to allow proper injection.</p> <p>When done correctly, providers with fewer dependencies will load before those with many, ensuring an efficient loading order.</p>"},{"location":"tutorials/fundamentals/dependencies/#example","title":"Example","text":"<p><pre><code>local Dependency = {}\n\nfunction Depdendency.hello()\n    print(\"Hello world!\")\nend\n\nreturn artwork.register(Dependency)\n-- IMPORTANT: make sure to register your dependencies else\n-- the dependency injection will not work\n</code></pre> <pre><code>-- Provider.luau\nlocal Dependency = require(\"Dependency\")\nlocal Provider = {\n    myDependency = Dependency,\n}\n\nProvider.myDependency.hello()\n\nreturn artwork.register(Provider)\n-- only when Dependency is registered, the dependency\n-- will be injected\n</code></pre></p>"},{"location":"tutorials/fundamentals/lifecycles/","title":"Lifecycle Events","text":""},{"location":"tutorials/fundamentals/lifecycles/#built-in-lifecycle-events","title":"Built-in Lifecycle Events","text":""},{"location":"tutorials/fundamentals/lifecycles/#onstart","title":"onStart","text":"<p>The <code>onStart</code> lifecycle event is similar to <code>onInit</code>, however, instead of calling each event sequentially, they are all called at the same time. This means yielding, or failures, in onStart won't affect others.</p>"},{"location":"tutorials/fundamentals/lifecycles/#oninit","title":"onInit","text":"<p>Avoid Use</p> <p>You should always use onStart except in very rare circumstances where you need the unique behavior of onInit.</p> <p>The <code>onInit</code> lifecycle event is one of the initialization events. This is only called once, and the function must complete successfully before the framework will call the next onInit or other events. It isnt recommended to yield in <code>onInit</code> since yielding will yield ignition. Errors and such will be logged but not pause execution.</p>"},{"location":"tutorials/fundamentals/lifecycles/#onstop","title":"onStop","text":"<p>The <code>onStop</code> lifecycle event is the opposite of <code>onStart</code>. It is called once right before the framework is shutdown. This is your chance to cleanup any resources that were allocated in <code>onStart</code> or anytime during execution.</p>"},{"location":"tutorials/fundamentals/lifecycles/#custom-lifecycle-events","title":"Custom Lifecycle Events","text":""},{"location":"tutorials/fundamentals/lifecycles/#custom-events","title":"Custom Events","text":"<p>Custom lifecycle events are a powerful feature that allows you to create custom lifecycle events that can be used by any module. To create a custom lifecycle event you can use the <code>artwork.createLifecycle</code> method.</p> <p>You can create client/server specific lifecycles with <code>artwork.createClientLifecycle</code> and <code>artwork.createServerLifecycle</code></p> <pre><code>local artwork = require(\"@packages/artwork\")\n\nartwork.createLifecycle(\"onPlayerAdded\", function(fire)\n    Players.PlayerAdded:Connect(fire)\n    for _, player in Players:GetPlayers() do\n        fire(player)\n    end\nend)\n\n-- then you can use the lifecycle event in any module like so:\nlocal provider = {}\n\nfunction provider.onPlayerAdded(player)\n    print(`Player {player.Name} joined the game! ({player.UserId})`)\nend\n\nartwork.register(provider)\n</code></pre>"},{"location":"tutorials/fundamentals/provider/","title":"Providers","text":"<p>Providers are objects that are registered with the framework. They work like every other <code>ModuleScript</code> in your code, but they can listen to lifecycles</p> <p>You can define a provider like you would define a module <pre><code>local provider = {}\nprovider.a = 1\n\nfunction provider.hello()\n    print(\"Hello World!\")\nend\n</code></pre></p>"},{"location":"tutorials/fundamentals/provider/#registering-a-provider","title":"Registering a provider","text":"<p>To register a provider, you can use the <code>artwork.register</code> function to register a object for listening to lifecycles. the priority can also be passed but it is optional <pre><code>return artwork.register(provider, 1)\n</code></pre></p>"},{"location":"tutorials/fundamentals/provider/#load-order","title":"Load Order","text":"<p>Dependency Injection</p> <p>This framework will automatically determine the correct load order for you, so it is recommended to avoid setting this manually. The property will take priority over the automatic order but providers with the same load order will still run in the automatic order.</p> <p>The higher the priority, the earlier the provider is registered on ignition. The default priority is <code>1</code> and providers with lower priority are registered after providers with a higher priority.</p> <p><pre><code>return artwork.register(provider, 0) -- will run BEFORE default priority\n</code></pre> <pre><code>return artwork.register(provider, 2) -- will run AFTER default priority\n</code></pre></p>"},{"location":"tutorials/fundamentals/startup/","title":"Preloading &amp; Ignition","text":"<p>To start the framework, you should load the required modules by calling the <code>loadDescendants</code> method. The <code>loadDescendants</code> method is a generic module loader that can be used to load modules from a given parent instance. The method accepts a parent of type <code>Instance</code> and an optional <code>predicate</code> function, which can be used to filter the descendants that should be loaded. If a <code>predicate</code> is provided, only the descendants for which the predicate returns <code>true</code> will be loaded.</p> <pre><code>local ReplicatedStorage = game:GetService(\"ReplicatedStorage\")\nartwork.loadDescendants(ReplicatedStorage.Shared)\n\n-- loading with custom predicate\nartwork.loadDescendants(ReplicatedStorage.Shared, function(instance)\n    return instance:HasTag(\"ignore\") == false\nend)\n\n-- custom loadChildren implementation\n-- this method is already built-in so this is a example\nlocal function loadChildren(parent, predicate)\n    return artwork.loadDescendants(parent, function(descendant)\n        local isChild = descendant.Parent == parent\n        return isChild and (not predicate or predicate(descendant))\n    end)\nend\n\nloadChildren(ReplicatedStorage.Modules)\n</code></pre>"},{"location":"tutorials/fundamentals/startup/#ignition","title":"Ignition!","text":"<p>After loading the providers you can then ignite the framework! Igniting the framework will initialize all registered providers in the order of their priority. The priority of a provider is used to determine the order in which the providers are registered.</p> <p>Warning</p> <p>Loading providers will NOT register the module. The loadDescendants/loadChildren methods dont have any special features other than loading modules. In order to register a provider, you must use the <code>artwork.register</code> method.</p> <p>If you want to check if the framework is currently ignited, you can use the <code>artwork.ignited</code> method, which returns a boolean indicating whether the framework is currently ignited or not.</p> <pre><code>artwork.ignite()\n</code></pre>"}]}